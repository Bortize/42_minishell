# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    notes_on_parser.txt                                :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: vicmarti <vicmarti@student.42madrid>       +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2021/08/02 20:19:57 by vicmarti          #+#    #+#              #
#    Updated: 2021/08/02 22:08:03 by vicmarti         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

The minishell subject does not ask for a fully functional bash, so most expansions
and syntax special symbols aren't included.

On character significance.

There are basically 4 kinds of characters based on minishell's parser behavior.
	LITERAL:	These characters are copied as-is. No special meaning to the parser.
	DOLLAR:		Metacharacter instructing that the following text is a variable,
	what set of chacters define a variable is a can on worms deserving a separate section.
	SYNTACTIC:	The meaning associated to these affects the way the parser interprets
		the tokens around it (usually, after), and changes the way command are run.
	QUOTING:	Metacharacters that change the behavior of the parser. Most notably,
		\, " and '.

On bash variables.

Bash variables are strings and expand to the --literal-- text they contain.
The value, of course updates the value of the text. A variable won't hold into
itself an special character with special meaning.

So for on my tests on bash variables, available characters are alphanumeric
strings, allowing underscores, and the first character mustn't be a digit.
Special bash variables exist such as '?' as $? to hold last execution's exit status.

On quoting.

Single quotes (') mark all text as literal until a closing pair is found.
Double quotes (") mark all text as literal except for DOLLAR characters until a
closing pair is found. In other words it does not inhibit variable expansion. It
also doesn't inhibit \.
Backslash (\), we need not implement it, but is a literal interpretation of the
following character. It behaves differently while 'double quoted'.

On syntax.

	SPACE:	Spaces just separate tokens, and several spaces might appear together.
	|:		Pipes redirect previous cmd output into next cmd input. I must separate
		cmds, cmds are run at the same time.
	<:		Input redirection, separates tokens, and takes the next token as stdin
		for the corresponding command. It must have a literal token right after.
		several redirects 'touch' files, but only the last one is redirected.
		It has priority over pipe redirections.
	>:		Simpilar to < but for stdout, the last one is the redirection, it has
		priotrity over pipes.
	>>:		Append redirect, as the previous >, in append mode. When mixed with >
		the rule is the same, only the last output redirect is the affected one.
	<<:		Here-Doc seems like it sets the next token to and alternate EOF.
		As with previous, last one takes precedence.

